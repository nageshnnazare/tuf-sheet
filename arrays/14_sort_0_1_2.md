# 14. Sort Array of 0's, 1's, and 2's

**LeetCode**: [#75 - Sort Colors](https://leetcode.com/problems/sort-colors/)  
**Difficulty**: Medium

## Problem Statement

Given an array `nums` with `n` objects colored red, white, or blue, sort them **in-place** so that objects of the same color are adjacent, with colors in the order red, white, and blue.

Use integers `0`, `1`, and `2` to represent red, white, and blue respectively.

**Constraint**: Solve without using library's sort function and in O(1) space.

## Examples

### Example 1
```
Input: nums = [2, 0, 2, 1, 1, 0]
Output: [0, 0, 1, 1, 2, 2]
```

### Example 2
```
Input: nums = [2, 0, 1]
Output: [0, 1, 2]
```

## Constraints
- n == nums.length
- 1 ≤ n ≤ 300
- nums[i] is either 0, 1, or 2

## Visual Explanation

### ASCII Diagram - Dutch National Flag Algorithm

```
Array: [2, 0, 2, 1, 1, 0]

Three Pointers:
  low  = 0  (boundary for 0s)
  mid  = 0  (current element being examined)
  high = 5  (boundary for 2s)

Goal:
[0...0 | 1...1 | unknown | 2...2]
 ←low   mid→   ←high

Initial: [2, 0, 2, 1, 1, 0]
          ↑              ↑
         l,m             h

Step 1: mid=0, nums[mid]=2
  Swap with high
  [0, 0, 2, 1, 1, 2]
   ↑           ↑
  l,m          h
  high--

Step 2: mid=0, nums[mid]=0
  Element correct, mid++
  [ 0, 0, 2, 1, 1, 2]
      ↑        ↑
     l,m       h

Step 3: mid=1, nums[mid]=0
  Swap with low
  [0, 0, 2, 1, 1, 2]
      ↑  ↑     ↑
      l  m     h
  low++, mid++

Continue...

Final: [0, 0, 1, 1, 2, 2]
```

## Approach & Intuition

**Dutch National Flag Algorithm** (by Dijkstra):

**Three Regions**:
1. `[0...low-1]` → All 0s
2. `[low...mid-1]` → All 1s  
3. `[mid...high]` → Unknown (being processed)
4. `[high+1...n-1]` → All 2s

**Rules**:
- If nums[mid] = 0: Swap with nums[low], increment both low and mid
- If nums[mid] = 1: Just increment mid (already in correct region)
- If nums[mid] = 2: Swap with nums[high], decrement high (don't increment mid!)

## Algorithm Steps

1. Initialize low=0, mid=0, high=n-1
2. While mid ≤ high:
   - If nums[mid] == 0:
     - swap(nums[low], nums[mid])
     - low++, mid++
   - Else if nums[mid] == 1:
     - mid++
   - Else (nums[mid] == 2):
     - swap(nums[mid], nums[high])
     - high--
3. Array is sorted!

## Dry Run

```
nums = [2, 0, 2, 1, 1, 0]
low = 0, mid = 0, high = 5

Iteration 1: mid=0, nums[mid]=2
  Case: 2 → swap with high
  swap(nums[0], nums[5]): [0, 0, 2, 1, 1, 2]
  high = 4
  State: low=0, mid=0, high=4

Iteration 2: mid=0, nums[mid]=0
  Case: 0 → swap with low (same position, no effect)
  low=1, mid=1
  State: [0, 0, 2, 1, 1, 2], low=1, mid=1, high=4

Iteration 3: mid=1, nums[mid]=0
  Case: 0 → swap with low
  swap(nums[1], nums[1]): no change
  low=2, mid=2
  State: [0, 0, 2, 1, 1, 2], low=2, mid=2, high=4

Iteration 4: mid=2, nums[mid]=2
  Case: 2 → swap with high
  swap(nums[2], nums[4]): [0, 0, 1, 1, 2, 2]
  high=3
  State: low=2, mid=2, high=3

Iteration 5: mid=2, nums[mid]=1
  Case: 1 → just move mid
  mid=3
  State: [0, 0, 1, 1, 2, 2], low=2, mid=3, high=3

Iteration 6: mid=3, nums[mid]=1
  Case: 1 → just move mid
  mid=4
  State: mid=4 > high=3, STOP

Final: [0, 0, 1, 1, 2, 2] ✓
```

## C++ Solution

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();
        
        // Three pointers for Dutch National Flag algorithm
        int low = 0;    // Boundary for 0s (everything before low is 0)
        int mid = 0;    // Current element being examined
        int high = n - 1; // Boundary for 2s (everything after high is 2)
        
        // Process until mid crosses high
        while (mid <= high) {
            if (nums[mid] == 0) {
                // Found a 0, should be in left partition
                // Swap with element at low pointer
                swap(nums[low], nums[mid]);
                
                // Expand the 0s region
                low++;
                
                // Move to next element
                // We can safely move mid because we know nums[low]
                // was either 0 or 1 (region between low and mid is sorted)
                mid++;
            }
            else if (nums[mid] == 1) {
                // Found a 1, it's already in correct region
                // Just expand the 1s region
                mid++;
            }
            else { // nums[mid] == 2
                // Found a 2, should be in right partition
                // Swap with element at high pointer
                swap(nums[mid], nums[high]);
                
                // Shrink the unknown region from right
                high--;
                
                // DON'T increment mid!
                // Element we just swapped from high is unknown
                // Need to process it in next iteration
            }
        }
        
        // Array is now sorted: [0...0, 1...1, 2...2]
    }
    
    // Alternative: Two-pass counting sort (simpler but makes two passes)
    void sortColorsCountingSort(vector<int>& nums) {
        int count0 = 0, count1 = 0, count2 = 0;
        
        // First pass: count occurrences
        for (int num : nums) {
            if (num == 0) count0++;
            else if (num == 1) count1++;
            else count2++;
        }
        
        // Second pass: overwrite array
        int i = 0;
        while (count0--) nums[i++] = 0;
        while (count1--) nums[i++] = 1;
        while (count2--) nums[i++] = 2;
    }
};

int main() {
    Solution sol;
    
    // Test Case 1
    vector<int> nums1 = {2, 0, 2, 1, 1, 0};
    cout << "Original: [2, 0, 2, 1, 1, 0]" << endl;
    sol.sortColors(nums1);
    cout << "Sorted:   [";
    for (int i = 0; i < nums1.size(); i++) {
        cout << nums1[i];
        if (i < nums1.size() - 1) cout << ", ";
    }
    cout << "]" << endl << endl;
    
    // Test Case 2
    vector<int> nums2 = {2, 0, 1};
    cout << "Original: [2, 0, 1]" << endl;
    sol.sortColors(nums2);
    cout << "Sorted:   [";
    for (int i = 0; i < nums2.size(); i++) {
        cout << nums2[i];
        if (i < nums2.size() - 1) cout << ", ";
    }
    cout << "]" << endl;
    
    return 0;
}
```

### Complexity Analysis

**Dutch National Flag**:
- **Time**: O(n) - Single pass
- **Space**: O(1) - Only three pointers

**Counting Sort**:
- **Time**: O(2n) = O(n) - Two passes
- **Space**: O(1) - Only three counters

## Key Insights & Interview Tips

1. **Dutch National Flag** - Classic partitioning algorithm
2. **One Pass** - Single traversal is key
3. **Three-way Partition** - Divides into three regions
4. **Don't Increment mid** after swapping with high (unknown element!)
5. **Follow-up**: "Sort k colors?" → Use quicksort or counting sort
6. **Related**: Partition in QuickSort, 3-way partitioning

